# @package _global_
defaults:
  - place
  - /habitat/task/measurements:
    - base_to_object_distance
  - /habitat/task/lab_sensors:
    - end_effector_pose_sensor
  - override /habitat/simulator/sensor_setups@habitat.simulator.agents.main_agent: spot_agent_jaw_sensor_irs
  - override /habitat/simulator/agents@habitat.simulator.agents.main_agent: spot_real
  - override /habitat/task/rearrange/actions: spot_base_arm_empty
  - override /habitat/dataset/rearrangement: hssd
  - _self_

# This yaml is designed specifically for learning a semantic place policy for the Boston Dynamics Spot robot.
# It uses the base place yaml to define the basic measurements and sensors,
# observation keys, and reward function to train the policy.
# The major changes compared to the base place yaml are the following:
# (1) obs_keys: we ensure these observations can be obtained from the real robot (Spot)
# (2) place_reward: place reward considers collisions based on a kinematic simulation
# (3) actions: Spot uses arm action to place the object
# (4) simulator: we simulate the environment via the kinematic mode to facilitate sim2real transfer
habitat:
  gym:
    obs_keys:
      - obj_goal_sensor
      - relative_initial_ee_orientation
      - relative_target_object_orientation
      - articulated_agent_jaw_depth
      - ee_pose
      - is_holding
  task:
    measurements:
      force_terminate:
        # We ignore the force here since in kinematic simulation, there is no force
        max_accum_force: -1.0
        max_instant_force: -1.0
      place_reward:
        wrong_drop_should_end: True
        drop_pen: 5.0
        count_coll_pen: 0.10
        max_count_colls: 5
        count_coll_end_pen: 8
        # We want to check if the object is placed on the receptacle
        obj_at_receptacle_success: True
        # We want to give the reward for ee orientation to initial orientation
        use_ee_ori: True
        use_obj_ori: False
        object_orientation_to_target_threshold: -1.0
        dist_reward: 20.0 
        ori_reward: 10.0 
        ee_orientation_to_initial_threshold: 0.1
        ee_to_target_threshold: -1.0
        min_dist_to_goal: 0.15
        slack_reward: -0.03
      place_success:
        ee_resting_success_threshold: -1.0
        # We want to check if the object is placed on the receptacle
        obj_at_receptacle_success: True
        # We want to check if the robot maintains the same ee's orientation
        ee_orientation_to_initial_threshold: 0.1
        # We want to make sure that the robot reaches the target pose
        object_orientation_to_target_threshold: -1.0
        ee_to_target_threshold: -1.0
      obj_at_goal:
        # We want this number to be as small as possible
        # since we want the robot to place the object precisely on the receptacle
        succ_thresh: 0.05
      obj_at_receptacle:
        vertical_diff_threshold: 0.1
        horizontal_diff_threshold: 0.15
        surface_vertical_diff_threshold: -1.0
        snap_down_surface_vertical_diff_threshold: 0.1
    lab_sensors:
      # We can only control 4 of the joints of Spot's arm
      joint_sensor:
        # We may want to use dimension 5 for controlling the rotation
        dimensionality: 5
        arm_joint_mask: [1,1,0,1,0,1,1]
        use_real_world_conventions: True
      goal_sensor:
        only_one_target: True
        use_base_transform: True
        use_real_world_conventions: True
      end_effector_pose_sensor:
        use_real_world_conventions: True
      relative_end_effector_orientation_sensor:
        use_smallest_angle: True 
        use_real_world_conventions: True
      relative_target_object_orientation_sensor:
        offset_yaw: True 
        use_real_world_conventions: True
      relative_resting_pos_sensor:
        use_real_world_conventions: True
    actions:
      base_velocity_non_cylinder: 
        longitudinal_lin_speed: 0.0 
        ang_speed: 0.0 
        allow_dyn_slide: False 
        navmesh_offset: [[0.0,0.0],[0.20,0.0],[-0.20,0.0]] 
      arm_action:
        arm_controller: "ArmEEAction"
        center_cone_vector: [0.0, 1.0, 0.0]
        arm_joint_mask: [1,1,0,1,0,1,1]
        arm_joint_dimensionality: 5
        auto_grasp: False
        should_clip: True
        delta_pos_limit: 0.01667 
        # We limit the joint angles to ensure that this is feasible in the real world
        arm_joint_limit: [[-1.5708,1.5708],[-3.1415,0.0000],[0,3.1415],[-1.5708,1.5708],[-1.5708,1.5708]] 
        ee_ctrl_lim: 0.015
        use_ee_rot: True
        ee_rot_ctrl_lim: 0.015
        render_ee_target: False
        use_contact_test: False
    success_reward: 10.0
    slack_reward: -0.03
    # Control Spot robot place location
    spawn_max_dist_to_obj: 1.0
    base_angle_noise: 0.523599
    top_down_grasp: True
    top_down_grasp_ratio: 1.0
    fix_obj_rotation_change_arm_joint: True 
    joint_start_noise: 1.0 
    joint_start_noise_multiplier: [0.1,0.1,0.1,0.1,0.1,0.1,0.1]
    init_joint_angles: [0.0, -3.14, 0.0, 3.14, 0.0, 0.0, 1.57]
    enable_rotation_target: False 
    render_target: False
    spawn_type: "orig_snap"
  simulator:
    # We use the kinematic mode to train the policy
    kinematic_mode: False
    ac_freq_ratio: 1
    ctrl_freq: 120
    step_physics: True
    use_real_world_conventions: True
    agents:
      main_agent:
        joint_start_noise: 0.0
        joint_that_can_control: [1, 1, 0, 1, 0, 1, 0]
        # The real-world gaze ready location
        joint_start_override: [0.0,-2.09,0.0,1.047,0.0,1.536,0.0]
        # joint_start_override_random: [[0.0,-2.09,0.0,1.047,0.0,1.536,0.0],[0.0,-2.09,0.0,1.047,0.0,1.536,1.57],[0.0,-2.09,0.0,1.047,0.0,1.536,-1.57],[0.0,-2.79,0.0,1.74,0.0,1.31,0.0],[0.0,-2.79,0.0,1.74,0.0,1.31,1.57],[0.0,-2.79,0.0,1.74,0.0,1.31,-1.57]]
        arm_joint_limit: [[-1.5708,1.5708],[-3.1415,0.0000],[0,3.1415],[-1.5708,1.5708],[-1.5708,1.5708]] 
  dataset:
    data_path: data/datasets/hssd/rearrange/{split}/social_rearrange.json.gz
